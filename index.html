<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Dashboard & News (Auto-updating)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        :root {
            --bg-color: #ffffff;
            --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --text-primary: #2c3e50;
            --text-secondary: #555;
            --border-color: #e0e0e0;
            --header-bg: #f8f9fa;
            --hover-bg: #f5f5f5;
            --modal-bg: #fefefe;
            --modal-overlay-bg: rgba(0,0,0,0.6);
            --button-bg: #f0f0f0;
            --button-active-bg: #d1e3f8;
            --shadow-light: 0 4px 20px rgba(0, 0, 0, 0.08);
            --shadow-strong: 0 5px 20px rgba(0,0,0,0.3);
            --primary-color: #4a90e2;
            --positive-color: #28a745;
            --negative-color: #dc3545;
        }

        body.dark-mode {
            --bg-color: #1a1a1a;
            --bg-gradient: linear-gradient(135deg, #2c3e50 0%, #1a1a1a 100%);
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --border-color: #444;
            --header-bg: #2c3e50;
            --hover-bg: #3a4a5a;
            --modal-bg: #282828;
            --modal-overlay-bg: rgba(0,0,0,0.8);
            --button-bg: #333;
            --button-active-bg: #4a90e2;
            --shadow-light: 0 4px 20px rgba(0, 0, 0, 0.3);
            --shadow-strong: 0 5px 20px rgba(0,0,0,0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; 
            background: var(--bg-gradient); 
            min-height: 100vh; 
            color: var(--text-primary); 
            transition: background-color 0.3s, color 0.3s;
        }
        .container { max-width: 1800px; margin: 0 auto; padding: 15px; }
        
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); display: flex;
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 9999; transition: opacity 0.3s ease; color: white;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2); width: 48px; height: 48px;
            border-radius: 50%; border-left-color: var(--primary-color);
            animation: spin 1s ease infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #loading-text { margin-top: 20px; font-size: 1.2rem; font-weight: 500; }
        
        .main-content {
            background: var(--bg-color); border-radius: 12px;
            padding: 25px; box-shadow: var(--shadow-light);
            transition: background-color 0.3s;
        }

        .header-controls {
            display: flex; justify-content: flex-end; align-items: center;
            margin-bottom: 10px;
        }
        #theme-toggle {
            cursor: pointer; background: none; border: none; padding: 5px;
            display: flex; align-items: center; justify-content: center;
        }
        #theme-toggle svg { width: 24px; height: 24px; fill: var(--text-primary); }

        .tabs { 
            display: flex; border-bottom: 2px solid var(--border-color); margin-bottom: 20px;
            position: sticky; top: 0; background: var(--bg-color); z-index: 100;
        }
        .tab-link { 
            padding: 10px 20px; cursor: pointer; border-bottom: 3px solid transparent; 
            margin-bottom: -2px; font-size: 1.1rem; font-weight: 500; transition: all 0.3s ease;
            color: var(--text-secondary);
        }
        .tab-link:hover { color: var(--primary-color); }
        .tab-link.active { 
            color: var(--primary-color); border-bottom-color: var(--primary-color); font-weight: 600;
        }
        
        .tab-content { display: none; animation: fadeIn 0.5s; }
        .tab-content.active { display: block; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .market-sub-tabs, .view-toggle-tabs, .chart-time-controls, .summary-period-controls, .cross-market-controls { 
            display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 15px; flex-wrap: wrap;
        }
        .market-sub-tab-link, .view-toggle-tab, .chart-time-controls button, .summary-period-controls button, .cross-market-controls button {
            padding: 8px 15px; cursor: pointer; font-size: 0.95rem; font-weight: 500;
            color: var(--text-secondary); border: none; background-color: var(--button-bg);
            margin: 0 5px 5px 0; border-radius: 6px; transition: all 0.3s ease;
        }
        .market-sub-tab-link:hover, .view-toggle-tab:hover, .chart-time-controls button:hover, .summary-period-controls button:hover, .cross-market-controls button:hover { color: var(--primary-color); }
        
        .market-sub-tabs { border-bottom-style: solid; border-bottom-width: 2px; }
        .market-sub-tab-link { background: none; margin-bottom: -2px; border-bottom: 3px solid transparent; }
        
        .market-sub-tab-link.active, .view-toggle-tab.active, .chart-time-controls button.active, .summary-period-controls button.active, .cross-market-controls button.active {
            color: var(--primary-color); background-color: var(--button-active-bg); font-weight: 600;
        }
        body.dark-mode .market-sub-tab-link.active, body.dark-mode .view-toggle-tab.active, body.dark-mode .chart-time-controls button.active, body.dark-mode .summary-period-controls button.active, body.dark-mode .cross-market-controls button.active {
            color: #fff;
        }
        .market-sub-tab-link.active { border-bottom-color: var(--primary-color); background: none; }
        .cross-market-controls { border-bottom: none;}


        .market-sub-tab-content { display: none; animation: fadeIn 0.4s; }
        .market-sub-tab-content.active { display: block; }
        .view-content { display: none; }
        .view-content.active { display: block; }

        .table-container { 
            overflow: auto; max-height: 600px;
            border: 1px solid var(--border-color); border-radius: 8px;
        }
        table { width: 100%; border-collapse: collapse; text-align: right; }
        th, td { padding: 8px 12px; border-bottom: 1px solid var(--border-color); white-space: nowrap; font-size: 0.95rem;}
        th:first-child, td:first-child { text-align: left; }
        th { 
            background-color: var(--header-bg); font-weight: 600; user-select: none;
            position: sticky; top: 0; z-index: 10;
        }
        th[data-sort-key] { cursor: pointer; }
        th[data-sort-key] .sort-icon {
            opacity: 0.4;
            display: inline-block;
            margin-left: 4px;
            font-family: monospace;
        }
        th[data-sort-key]:hover .sort-icon { opacity: 1; }
        th.custom-date-header { text-decoration: underline; text-decoration-style: dashed; cursor: pointer; }
        
        tr:hover { background-color: var(--hover-bg); }
        .clickable-row { cursor: pointer; }
        .text-positive { color: var(--positive-color) !important; font-weight: 500; }
        .text-negative { color: var(--negative-color) !important; font-weight: 500; }
        
        .chart-controls { display: flex; gap: 10px; margin-bottom: 15px; align-items: center; flex-wrap: wrap; }
        .chart-controls label { font-weight: 500; }
        .chart-controls input {
            flex-grow: 1; border: 1px solid var(--border-color); padding: 8px; 
            border-radius: 6px; min-width: 250px; font-size: 1rem;
            background-color: var(--bg-color); color: var(--text-primary);
        }
        .chart-controls button.update-btn {
             background-color: var(--primary-color); color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer;
        }
        .custom-date-inputs { display: none; gap: 10px; align-items: center; }
        .custom-date-inputs.active { display: flex; }
        
        .modal {
            position: fixed; z-index: 1001; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto;
            background-color: var(--modal-overlay-bg);
            opacity: 0; 
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal.show { 
            opacity: 1; 
            pointer-events: auto;
        }
        .modal-content {
            background-color: var(--modal-bg); margin: 5% auto; padding: 25px;
            border-radius: 12px; width: 90%; max-width: 1200px; box-shadow: var(--shadow-strong);
            position: relative;
            transform: translateY(-50px); transition: transform 0.3s ease-out;
        }
        .modal.show .modal-content { transform: translateY(0); }
        .close {
            color: #aaa; position: absolute; top: 10px; right: 20px;
            font-size: 28px; font-weight: bold; cursor: pointer;
        }
        .modal-header { text-align: center; margin-bottom: 10px; color: var(--text-primary); }
        .modal-chart-container { position: relative; height: 500px; width: 100%; }

        #tickerSelectionModal .modal-content, #confirmationModal .modal-content { max-width: 500px; }
        #ticker-selection-list { list-style: none; margin-top: 15px; max-height: 40vh; overflow-y: auto; }
        #ticker-selection-list li {
            padding: 12px; border: 1px solid var(--border-color);
            border-radius: 6px; margin-bottom: 8px; cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        #ticker-selection-list li:hover {
            background-color: var(--hover-bg);
            border-color: var(--primary-color);
        }
        .confirmation-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;}
        .btn-secondary {
            background-color: var(--button-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s;
        }
        .btn-secondary:hover {
            background-color: var(--hover-bg);
        }

        #summary { padding: 10px 0; }
        .summary-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
        .summary-header-left { display: flex; align-items: center; gap: 15px; flex-wrap: wrap;}
        .summary-header h2 { font-size: 1.5rem; color: var(--text-primary); }
        .print-btn { 
            background-color: var(--primary-color); color: white; border: none; padding: 10px 20px; 
            border-radius: 8px; cursor: pointer; font-size: 1rem; transition: background-color 0.3s, filter 0.3s;
        }
        .print-btn:hover {
            filter: brightness(110%);
        }
        #summary-content-to-print {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(380px, 1fr)); gap: 20px;
        }
        .summary-section { display: flex; flex-direction: column; gap: 20px; }
        .summary-card { 
            border: 1px solid var(--border-color); border-radius: 8px; padding: 15px;
            background: var(--bg-color); display: flex; flex-direction: column;
        }
        .summary-card h3 { 
            margin-bottom: 10px; font-size: 1.2rem; color: var(--text-primary); 
            border-bottom: 1px solid var(--border-color); padding-bottom: 8px;
        }
        .summary-card table { font-size: 0.9rem; table-layout: fixed; }
        .summary-card th, .summary-card td { padding: 6px 8px; }
        .summary-card tbody tr { cursor: default; } /* Changed from pointer */
        .summary-card td:first-child, .summary-card th:first-child { width: 35%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        #summary-news-content {
            white-space: pre-wrap; font-size: 0.95rem; line-height: 1.6;
            overflow-y: auto; flex-grow: 1; color: var(--text-secondary);
        }
         .news-meta { font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 15px; }

        .news-layout-container { display: flex; gap: 20px; height: 70vh; }
        .news-list-pane { flex: 1; overflow-y: auto; border-right: 1px solid var(--border-color); padding-right: 15px; }
        .news-content-pane { flex: 2; overflow-y: auto; padding-left: 15px; }
        .news-list-item {
            padding: 12px 8px; border-bottom: 1px solid var(--border-color); cursor: pointer;
            transition: background-color 0.2s ease; border-radius: 6px;
        }
        .news-list-item:hover, .news-list-item.active { background-color: var(--hover-bg); }
        .news-list-item h4 { font-size: 1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; }
        .news-list-item p { font-size: 0.85rem; color: var(--text-secondary); }
        .news-content-pane h3 { font-size: 1.4rem; color: var(--text-primary); margin-bottom: 8px; }
        .news-content-pane .news-meta { border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .news-content-pane .news-body { font-size: 1rem; line-height: 1.7; white-space: pre-wrap; color: var(--text-secondary); }

        #chart-tooltip {
            position: fixed; z-index: 9999;
            width: 320px; height: 200px;
            background: var(--modal-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px; box-shadow: var(--shadow-strong);
            pointer-events: none;
            opacity: 0; visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            padding: 10px;
        }
        #chart-tooltip.visible { opacity: 1; visibility: visible; }
        #chart-tooltip canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p id="loading-text">Loading latest data from GitHub...</p>
    </div>

    <div class="container">
        <div class="header-controls">
            <button id="theme-toggle" title="Toggle color mode">
                <span id="theme-icon-sun">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.64 5.64c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41l1.41 1.41c.39.39 1.02.39 1.41 0s.39-1.02 0-1.41L5.64 5.64zm12.73 12.73c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41l1.41 1.41c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41l-1.41-1.41zM5.64 18.36l-1.41-1.41c-.39-.39-.39-1.02 0-1.41 .39-.39 1.02-.39 1.41 0l1.41 1.41c.39.39.39 1.02 0 1.41-.39.39-1.03.39-1.41 0zm12.73-12.73l-1.41-1.41c-.39-.39-.39-1.02 0-1.41s1.02-.39 1.41 0l1.41 1.41c.39.39.39 1.02 0 1.41s-1.02.39-1.41 0z"/></svg>
                </span>
                <span id="theme-icon-moon" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07-6.25.21-11.21 5.19-11.21 11.49 0 6.34 5.16 11.49 11.49 11.49 5.3 0 9.68-3.66 11.01-8.44-.7.1-1.4.16-2.1.16-4.54 0-8.23-3.69-8.23-8.23 0-.64.07-1.25.19-1.84z"/></svg>
                </span>
            </button>
        </div>

        <div class="main-content">
            <div class="tabs">
                <div class="tab-link active" onclick="openTab(event, 'summary')">Summary</div>
                <div class="tab-link" onclick="openTab(event, 'market')">Market</div>
                <div class="tab-link" onclick="openTab(event, 'news')">News</div>
            </div>
            
            <div id="summary" class="tab-content active">
                <div class="summary-header">
                    <div class="summary-header-left">
                        <h2 id="summary-title">Market Summary</h2>
                        <div class="summary-period-controls">
                            <button data-period="1w" onclick="updateSummaryView({period: '1w'}, this)">1-Week</button>
                            <button data-period="mtd" onclick="updateSummaryView({period: 'mtd'}, this)">MTD</button>
                            <button data-period="1m" onclick="updateSummaryView({period: '1m'}, this)">1-Month</button>
                            <button data-period="3m" onclick="updateSummaryView({period: '3m'}, this)">3-Month</button>
                            <button data-period="ytd" class="active" onclick="updateSummaryView({period: 'ytd'}, this)">YTD</button>
                            <button data-period="1y" onclick="updateSummaryView({period: '1y'}, this)">1-Year</button>
                            <button data-period="custom" onclick="openCustomDateModal('summary')">Custom</button>
                        </div>
                        <button class="display-mode-toggle print-btn" style="padding: 8px 12px; font-size: 0.9rem; background-color: #6c757d;" onclick="togglePerformanceDisplayMode()">Show Points</button>
                    </div>
                    <button class="print-btn" onclick="window.print()">Print Summary (PDF)</button>
                </div>
                <div id="summary-content-to-print">
                    <div class="summary-section">
                        <div id="summary-index" class="summary-card"></div>
                        <div id="summary-rate" class="summary-card"></div>
                        <div id="summary-commodity" class="summary-card"></div>
                    </div>
                    <div class="summary-section">
                        <div id="summary-fx" class="summary-card"></div>
                        <div id="summary-stocks" class="summary-card"></div>
                    </div>
                     <div class="summary-section">
                        <div id="summary-news-card" class="summary-card">
                             <h3>Latest News Summary</h3>
                            <div id="summary-news-content"><p>Loading news...</p></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="market" class="tab-content">
                <div id="market-sub-tabs-container" class="market-sub-tabs"></div>
                <div id="market-sub-content-container"></div>
            </div>

            <div id="news" class="tab-content">
                <div id="news-sub-tabs-container" class="market-sub-tabs"></div>
                <div id="news-sub-content-container"></div>
            </div>
        </div>
    </div>

    <div id="tickerModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('tickerModal')">&times;</span>
            <h2 id="modalTickerName" class="modal-header"></h2>
            <div class="chart-time-controls" id="modal-time-controls">
                 <button data-period="3m">3-Month</button>
                 <button data-period="6m">6-Month</button>
                 <button data-period="ytd">YTD</button>
                 <button class="active" data-period="last_calendar">Since Last Year</button>
                 <button data-period="5y">5-Year</button>
            </div>
            <div class="modal-chart-container"><canvas id="individualTickerChart"></canvas></div>
        </div>
    </div>

    <div id="datePickerModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <span class="close" onclick="closeModal('datePickerModal')">&times;</span>
            <h3 class="modal-header">Select Custom Date Range</h3>
            <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 20px;">
                <div>
                    <label for="customStartDate">Start Date:</label>
                    <input type="date" id="customStartDate" class="chart-controls input" style="width: 100%;">
                </div>
                <div>
                    <label for="customEndDate">End Date:</label>
                    <input type="date" id="customEndDate" class="chart-controls input" style="width: 100%;">
                </div>
                <button id="applyCustomDate" class="print-btn" style="align-self: flex-end;">Apply</button>
            </div>
        </div>
    </div>

    <div id="confirmationModal" class="modal">
        <div class="modal-content">
            <h3 id="confirmationTitle" class="modal-header">Change Ticker</h3>
            <p id="confirmationMessage" style="text-align: center; margin: 20px 0; font-size: 1.1rem;"></p>
            <div class="confirmation-buttons">
                <button id="confirmBtnNo" onclick="closeModal('confirmationModal')" class="btn-secondary">Cancel</button>
                <button id="confirmBtnYes" class="print-btn">Confirm</button>
            </div>
        </div>
    </div>

    <div id="tickerSelectionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('tickerSelectionModal')">&times;</span>
            <h3 id="tickerSelectionTitle" class="modal-header">Select a Ticker</h3>
            <ul id="ticker-selection-list"></ul>
        </div>
    </div>

    <div id="chart-tooltip"><canvas id="tooltip-canvas"></canvas></div>

    <script>
        // --- Global Variables ---
        let allData = [], dataByMarket = {}, allNewsData = [], newsByCategory = {};
        let activeCharts = {}, allPerformanceData = new Map();
        let latestDataDate = null, marketSortState = {};
        let currentSummaryPeriod = { period: 'ytd' };
        let tooltipChart = null;
        let tooltipTimeout = null;
        let activeCustomDateContext = null;
        let currentCrossMarketPeriod = { period: 'ytd' };
        let performanceDisplayMode = 'percent'; // 'percent' or 'points'
        
        // --- Chart Colors ---
        const CHART_COLORS = [
            '#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F',
            '#EDC948', '#B07AA1', '#FF9DA7', '#9C755F', '#BAB0AC'
        ];

        // --- Cross Market Chart Data (Global for modification) ---
        let crossMarketAssets = {
            labels: ['S&P 500', 'TWSE Index', 'TSM (ADR)', 'TSMC (TW)', 'UST 2Y', 'UST 10Y', 'DXY Index', 'TWD', 'Gold'],
            tickers: ['.SPX', '.TWII', 'TSM.N', '2330.TW', 'US2YT=RR', 'US10YT=RR', '.DXY', 'TWD=', 'GCc1'],
            types: ['perf', 'perf', 'perf', 'perf', 'bps', 'bps', 'perf', 'perf', 'perf'],
            groups: ['Equity Index', 'Equity Index', 'Stocks', 'Stocks', 'US Rates', 'US Rates', 'FX', 'FX', 'Commodity']
        };

        // --- Utility Functions ---
        function formatNumberWithCommas(num) {
            if (num === null || num === undefined) return 'N/A';
            const numStr = String(num);
            const parts = numStr.split('.');
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            return parts.join('.');
        }

        function getStartDate(period, referenceDate) {
            const d = new Date(referenceDate);
            d.setHours(0,0,0,0);
            switch(period) {
                case '1d': d.setDate(d.getDate() - 1); return d;
                case '1w': d.setDate(d.getDate() - 7); return d;
                case 'mtd': return new Date(d.getFullYear(), d.getMonth(), 1);
                case '1m': d.setMonth(d.getMonth() - 1); return d;
                case '3m': d.setMonth(d.getMonth() - 3); return d;
                case 'ytd': return new Date(d.getFullYear(), 0, 1);
                case '1y': d.setFullYear(d.getFullYear() - 1); return d;
                case 'lastYear': return { start: new Date(d.getFullYear() - 1, 0, 1), end: new Date(d.getFullYear() - 1, 11, 31) };
                default: return null;
            }
        }

        // --- Initialization & Data Loading ---
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
            window.addEventListener('resize', adjustSummaryNewsHeight);
            loadAllDataFromGitHub();
        });
        
        async function fetchJsonWithRetry(url, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(`${url}?v=${new Date().getTime()}`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.log(`Attempt ${i + 1} failed for ${url}: ${error.message}`);
                    if (i < retries - 1) await new Promise(res => setTimeout(res, delay)); else throw error;
                }
            }
        }

        async function loadAllDataFromGitHub() {
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingText = document.getElementById('loading-text');
            const marketDataUrls = {
                'Equity Index': 'https://raw.githubusercontent.com/andychu221/yhfinance-fred-data/main/market_data/Equity_Index.json',
                'Commodity': 'https://raw.githubusercontent.com/andychu221/yhfinance-fred-data/main/market_data/Commodity.json',
                'FX': 'https://raw.githubusercontent.com/andychu221/yhfinance-fred-data/main/market_data/FX.json',
                'TW Stocks': 'https://raw.githubusercontent.com/andychu221/yhfinance-fred-data/main/market_data/TW_Stocks.json',
                'US Stocks': 'https://raw.githubusercontent.com/andychu221/yhfinance-fred-data/main/market_data/US_Stocks.json',
                'US Rates': 'https://raw.githubusercontent.com/andychu221/yhfinance-fred-data/main/market_data/US_Rates.json'
            };
            const newsDataUrl = 'https://raw.githubusercontent.com/andychu221/reuters-news-archive/main/reuters_archive.json';
            const tickersToExclude = ['5347.TWO', '3443.TW', '3374.TWO', '6789.TW'];

            try {
                loadingText.textContent = 'Loading market data...';
                const marketPromises = Object.entries(marketDataUrls).map(([marketName, url]) => fetchJsonWithRetry(url).then(data => ({ marketName, data })).catch(() => ({ marketName, data: null })));
                const newsPromise = fetchJsonWithRetry(newsDataUrl).catch(() => null);

                const [marketResults, newsResult] = await Promise.all([Promise.all(marketPromises), newsPromise]);

                loadingText.textContent = 'Processing market data...';
                allData = [];
                marketResults.forEach(result => {
                    if (!result || !result.data) return;
                    Object.entries(result.data).forEach(([ticker, details]) => {
                        if (tickersToExclude.includes(ticker)) return;
                        if (details && details.data) {
                            Object.entries(details.data).forEach(([dateStr, price]) => {
                                if (price !== null) {
                                    allData.push({ 
                                        ticker, 
                                        name: details.name, 
                                        market: result.marketName, 
                                        date: new Date(dateStr),
                                        price: parseFloat(price),
                                        originalDateStr: dateStr 
                                    });
                                }
                            });
                        }
                    });
                });

                allData.sort((a, b) => a.date - b.date);
                if (allData.length > 0) {
                    latestDataDate = new Date(Math.max(...allData.map(d => d.date)));
                } else {
                    loadingText.textContent = 'No market data found.'; return;
                }

                processPriceData();

                loadingText.textContent = 'Processing news data...';
                if (newsResult && Array.isArray(newsResult.reports)) {
                    allNewsData = newsResult.reports.map(r => ({...r, datetime: new Date(`${r.Date}T${r.Time}`)})).filter(n => n.datetime.getTime()).sort((a, b) => b.datetime - a.datetime);
                    processNewsData();
                } else {
                    processNewsData();
                }

                loadingOverlay.style.opacity = '0';
                setTimeout(() => { loadingOverlay.style.display = 'none'; }, 300);

            } catch (error) {
                loadingText.textContent = `Failed to load data: ${error.message}`;
            }
        }

        function processPriceData() {
            allPerformanceData.clear();
            dataByMarket = allData.reduce((acc, row) => {
                if (!acc[row.market]) acc[row.market] = [];
                acc[row.market].push(row);
                return acc;
            }, {});

            const allTickers = [...new Set(allData.map(d => d.ticker))];
            allTickers.forEach(ticker => {
                const market = allData.find(d => d.ticker === ticker)?.market || 'Unknown';
                allPerformanceData.set(ticker, calculatePerformanceForTicker(ticker, market));
            });
            
            setupMarketTabs();
            renderSummaryTab();
        }

        // --- Performance Calculation ---
        function calculatePerformanceForTicker(ticker, market) {
            const tickerData = allData.filter(d => d.ticker === ticker).sort((a,b) => a.date - b.date);
            if(tickerData.length === 0) return {};

            const lastDataPoint = tickerData[tickerData.length - 1];
            const refDate = lastDataPoint.date;
            
            let lastTime = 'c';
            if (lastDataPoint.originalDateStr && lastDataPoint.originalDateStr.includes(' ')) {
                lastTime = lastDataPoint.originalDateStr.split(' ')[1];
            }
            
            const findPriceOnOrBefore = (date, data = tickerData) => {
                if (!date || isNaN(date.getTime())) return null;
                let closest = null;
                for (let i = data.length - 1; i >= 0; i--) {
                    if (data[i].date <= date) { closest = data[i]; break; }
                }
                return closest ? closest.price : null;
            };
            
            const isRate = market === 'US Rates';

            const formatValue = (val, type) => {
                if (val === null || isNaN(val)) return 'N/A';
                if (type === 'bps') return `${val.toFixed(0)} bps`;
                if (type === 'percent') return `${val.toFixed(2)}%`;
                if (type === 'points') return formatNumberWithCommas(val.toFixed(market === 'FX' ? 4 : 2));
                return val;
            };

            const calcPerf = (startPrice, endPrice, isRate, isInverted) => {
                if (startPrice === null || endPrice === null || startPrice === 0) return null;
                if (isRate) return (endPrice - startPrice) * 100;
                let result = ((endPrice / startPrice) - 1) * 100;
                return isInverted ? result * -1 : result;
            }

            const lastPrice = lastDataPoint.price;
            const invertedFx = ['JPY=', 'TWD=', 'KRW=', 'CNY='].some(inv => ticker.includes(inv));
            
            const perf = { 
                ticker, 
                name: tickerData[0].name, 
                market, 
                lastPrice: lastPrice, // Store as raw number for sorting
                lastPriceFormatted: formatNumberWithCommas(lastPrice.toFixed(market === 'FX' ? 4 : 2)), // Store formatted string for display
                lastDate: formatDateMMDD(refDate),
                lastTime: lastTime
            };
            
            const prevPrice1d = tickerData.length > 1 ? tickerData[tickerData.length - 2].price : null;
            const perf1d = calcPerf(prevPrice1d, lastPrice, isRate, invertedFx);
            perf['1d'] = formatValue(perf1d, isRate ? 'bps' : 'percent');
            perf['1d_raw'] = perf1d; // Store raw value for sorting
            perf['1d_pts'] = formatValue(prevPrice1d !== null ? (lastPrice - prevPrice1d) : null, 'points');
            perf['1d_pts_raw'] = prevPrice1d !== null ? (lastPrice - prevPrice1d) : null;
            
            ['1w', 'mtd', '1m', '3m', 'ytd', '1y'].forEach(p => {
                const startDate = getStartDate(p, refDate);
                const startPrice = findPriceOnOrBefore(startDate);
                const pPerf = calcPerf(startPrice, lastPrice, isRate, invertedFx);
                const pPts = startPrice !== null ? (lastPrice - startPrice) : null;
                perf[p] = formatValue(pPerf, isRate ? 'bps' : 'percent');
                perf[p + '_raw'] = pPerf;
                perf[p + '_pts'] = formatValue(pPts, 'points');
                perf[p + '_pts_raw'] = pPts;
            });

            const lastYearDates = getStartDate('lastYear', refDate);
            const startPriceLY = findPriceOnOrBefore(lastYearDates.start);
            const endPriceLY = findPriceOnOrBefore(lastYearDates.end);
            const perfLY = calcPerf(startPriceLY, endPriceLY, isRate, invertedFx);
            const pPtsLY = (startPriceLY !== null && endPriceLY !== null) ? endPriceLY - startPriceLY : null;
            perf.lastYear = formatValue(perfLY, isRate ? 'bps' : 'percent');
            perf.lastYear_raw = perfLY;
            perf.lastYear_pts = formatValue(pPtsLY, 'points');
            perf.lastYear_pts_raw = pPtsLY;

            perf.findPriceOnOrBefore = findPriceOnOrBefore;
            perf.calcPerf = calcPerf;

            return perf;
        }


        // --- Summary Tab ---
        function updateSummaryView(periodConfig, element) {
            currentSummaryPeriod = periodConfig;
            document.querySelectorAll('.summary-period-controls button').forEach(b => b.classList.remove('active'));
            if (element) element.classList.add('active');
            renderSummaryTab();
        }

        function renderSummaryTab() {
            const summaryConfig = {
                'index': { title: 'Index', tickers: ['.SPX', '.IXIC', '.SOX', '.TWII'], container: 'summary-index' },
                'rate': { title: 'US Rates', tickers: ['US3MT=RR', 'US2YT=RR', 'US10YT=RR', 'US30YT=RR'], container: 'summary-rate' },
                'fx': { title: 'FX', tickers: ['.DXY', 'EUR=', 'JPY=', 'TWD='], container: 'summary-fx' },
                'stocks': { title: 'Stocks', tickers: ['NVDA.O', 'AAPL.O', 'MSFT.O', 'GOOGL.O', 'META.O', 'AMZN.O', 'TSLA.O', 'AVGO.O', 'TSM.N', 'AMD.O', 'INTC.O'], container: 'summary-stocks' },
                'commodity': { title: 'Commodity', tickers: ['CLc1', 'GCc1'], container: 'summary-commodity'}
            };
            const periodLabels = {'1d': '1-Day', '1w':'1-Week', 'mtd': 'MTD', '1m':'1-Month', '3m':'3-Month', 'ytd':'YTD', '1y':'1-Year'};
            
            let perfKey = 'period' in currentSummaryPeriod ? currentSummaryPeriod.period : 'custom';
            let perfHeader = periodLabels[perfKey] || `${formatDateMMDD(new Date(currentSummaryPeriod.start))}-<br>${formatDateMMDD(new Date(currentSummaryPeriod.end))}`;
            
            const isPercent = performanceDisplayMode === 'percent';

            Object.values(summaryConfig).forEach(config => {
                const container = document.getElementById(config.container);
                if (!container) return;
                const data = config.tickers.map(t => allPerformanceData.get(t)).filter(Boolean);
                
                const isRate = config.title === 'US Rates';
                const unit = isRate ? '(bps)' : isPercent ? '(%)' : '(Pts)';
                const keySuffix = isPercent ? '' : '_pts';
                
                let tableHTML = `<h3>${config.title}</h3><table><thead><tr>
                    <th>Name</th><th>Date</th><th>Time</th><th>Last</th><th>1-Day ${unit}</th><th>${perfHeader} ${unit}</th>
                </tr></thead><tbody>`;
                
                data.forEach(item => {
                    let periodDisplayValue;
                    if(perfKey === 'custom') {
                        const start = new Date(currentSummaryPeriod.start);
                        const end = new Date(currentSummaryPeriod.end);
                        const inverted = ['JPY=', 'TWD=', 'KRW=', 'CNY='].some(inv => item.ticker.includes(inv));
                        const tickerData = allData.filter(d => d.ticker === item.ticker);
                        const startPrice = item.findPriceOnOrBefore(start, tickerData);
                        const endPrice = item.findPriceOnOrBefore(end, tickerData);
                        
                        if (isRate) {
                            const rawPerf = item.calcPerf(startPrice, endPrice, true, false);
                            periodDisplayValue = (rawPerf === null || isNaN(rawPerf)) ? 'N/A' : `${rawPerf.toFixed(0)} bps`;
                        } else {
                            if (isPercent) {
                                const rawPerf = item.calcPerf(startPrice, endPrice, false, inverted);
                                periodDisplayValue = (rawPerf === null || isNaN(rawPerf)) ? 'N/A' : `${rawPerf.toFixed(2)}%`;
                            } else {
                                const rawDiff = (startPrice !== null && endPrice !== null) ? endPrice - startPrice : null;
                                periodDisplayValue = (rawDiff === null || isNaN(rawDiff)) ? 'N/A' : formatNumberWithCommas(rawDiff.toFixed(item.market === 'FX' ? 4 : 2));
                            }
                        }
                    } else {
                       periodDisplayValue = isRate ? item[perfKey] : item[perfKey + keySuffix];
                    }

                    const day1DisplayValue = isRate ? item['1d'] : item['1d' + keySuffix];
                    const colorClass = val => (val === 'N/A' || parseFloat(String(val).replace(/,/g, '')) === 0) ? '' : parseFloat(String(val).replace(/,/g, '')) > 0 ? 'text-positive' : 'text-negative';
                    
                    tableHTML += `<tr data-ticker="${item.ticker}">
                        <td title="${item.name}">${item.name}</td><td>${item.lastDate}</td><td>${item.lastTime}</td><td>${item.lastPriceFormatted}</td>
                        <td class="${colorClass(day1DisplayValue)}">${day1DisplayValue}</td>
                        <td class="${colorClass(periodDisplayValue)}">${periodDisplayValue}</td>
                    </tr>`;
                });
                container.innerHTML = tableHTML + '</tbody></table>';
            });
            addSummaryTooltipEvents();
            adjustSummaryNewsHeight();
            document.getElementById('summary-title').textContent = 'Market Summary';
        }

        // --- Market Tab ---
        function setupMarketTabs() {
            const tabsContainer = document.getElementById('market-sub-tabs-container');
            const contentContainer = document.getElementById('market-sub-content-container');
            tabsContainer.innerHTML = ''; contentContainer.innerHTML = '';
            const markets = ['Cross Market', 'Equity Index', 'US Stocks', 'TW Stocks', 'FX', 'US Rates', 'Commodity'];
            
            markets.forEach((market, index) => {
                const marketDataExists = dataByMarket[market] || market === 'Cross Market';
                if (marketDataExists) {
                    const isActive = index === 0;
                    const marketId = market.replace(/\s/g, '-');
                    tabsContainer.innerHTML += `<div class="market-sub-tab-link ${isActive ? 'active' : ''}" onclick="openMarketSubTab('${market}')">${market}</div>`;
                    contentContainer.innerHTML += `<div id="market-${marketId}" class="market-sub-tab-content ${isActive ? 'active' : ''}"></div>`;
                    if (isActive) openMarketSubTab(market);
                }
            });
        }
        
        function openMarketSubTab(marketName) {
            document.querySelectorAll('#market-sub-tabs-container .market-sub-tab-link').forEach(link => link.classList.toggle('active', link.textContent === marketName));
            document.querySelectorAll('#market-sub-content-container .market-sub-tab-content').forEach(content => {
                const marketId = marketName.replace(/\s/g, '-');
                const isActive = content.id === `market-${marketId}`;
                content.classList.toggle('active', isActive);
                if (isActive && (!content.hasChildNodes() || marketName !== 'Cross Market')) {
                    if (marketName === 'Cross Market') {
                        renderCrossMarketTab();
                    } else {
                        renderMarketData(marketName);
                    }
                }
            });
        }

        function switchMarketView(market, view) {
            const marketId = market.replace(/\s/g, '-');
            document.querySelectorAll(`#market-${marketId} .view-toggle-tab`).forEach(tab => tab.classList.toggle('active', tab.dataset.view === view));
            document.querySelectorAll(`#market-${marketId} .view-content`).forEach(content => content.classList.toggle('active', content.id === `${view}-${marketId}`));
            
            if (view === 'chart') {
                const chartContainer = document.getElementById(`chart-${marketId}`);
                if (chartContainer && !chartContainer.hasChildNodes()) {
                    let performanceData = Array.from(allPerformanceData.values()).filter(d => d.market === market);
                    renderComparisonChartUI(market, performanceData);
                }
            }
        }

        function renderMarketData(market) {
            const marketId = market.replace(/\s/g, '-');
            const container = document.getElementById(`market-${marketId}`);
            if (!container) return;
            let performanceData = Array.from(allPerformanceData.values()).filter(d => d.market === market);
            
            const isPercent = performanceDisplayMode === 'percent';
            
            container.innerHTML = `
                <div class="view-toggle-tabs" style="display: flex; justify-content: space-between; align-items: center; width:100%;">
                    <div style="display: flex;">
                        <div class="view-toggle-tab active" data-view="table" onclick="switchMarketView('${market}', 'table')">Table</div>
                        <div class="view-toggle-tab" data-view="chart" onclick="switchMarketView('${market}', 'chart')">Chart</div>
                    </div>
                     <button class="display-mode-toggle print-btn" style="padding: 8px 12px; font-size: 0.9rem; background-color: #6c757d;" onclick="togglePerformanceDisplayMode()">${isPercent ? 'Show Points' : 'Show %'}</button>
                </div>
                <div id="table-${marketId}" class="view-content active"></div>
                <div id="chart-${marketId}" class="view-content"></div>`;
            
            document.getElementById(`table-${marketId}`).innerHTML = createPerformanceTable(performanceData, market);
            addTableEventListeners(market);
        }

        function createPerformanceTable(data, market) {
            const lastYear = latestDataDate.getFullYear() - 1;
            const isRate = market === 'US Rates';
            const isPercent = performanceDisplayMode === 'percent';
            const suffix = isRate ? ' (bps)' : isPercent ? ' (%)' : ' (Pts)';
            
            let tableHTML = `<thead><tr>
                <th data-sort-key="name">Name <span class="sort-icon"></span></th>
                <th data-sort-key="lastDate">Date <span class="sort-icon"></span></th>
                <th>Time</th>
                <th data-sort-key="lastPrice">Last <span class="sort-icon"></span></th>
                <th data-sort-key="1d">1-Day${suffix} <span class="sort-icon"></span></th>
                <th data-sort-key="1w">1-Week${suffix} <span class="sort-icon"></span></th>
                <th data-sort-key="mtd">MTD${suffix} <span class="sort-icon"></span></th>
                <th data-sort-key="1m">1-Month${suffix} <span class="sort-icon"></span></th>
                <th data-sort-key="3m">3-Month${suffix} <span class="sort-icon"></span></th>
                <th data-sort-key="ytd">YTD${suffix} <span class="sort-icon"></span></th>
                <th class="custom-date-header" onclick="openCustomDateModal('${market}')" data-period-label="${lastYear} Perf.${suffix}">${lastYear} Perf.${suffix}</th>
            </tr></thead><tbody>`;

            data.forEach(item => {
                const keySuffix = isPercent ? '' : '_pts';
                const colorClass = val => (val === null || val === undefined || val === 'N/A' || parseFloat(String(val).replace(/,/g, '')) === 0) ? '' : parseFloat(String(val).replace(/,/g, '')) > 0 ? 'text-positive' : 'text-negative';
                
                tableHTML += `<tr data-ticker="${item.ticker}" class="clickable-row">
                    <td>${item.name}</td><td>${item.lastDate}</td><td>${item.lastTime}</td><td>${item.lastPriceFormatted}</td>
                    ${['1d', '1w', 'mtd', '1m', '3m', 'ytd'].map(p => {
                        const displayValue = isRate ? item[p] : item[p + keySuffix];
                        return `<td class="${colorClass(displayValue)}">${displayValue}</td>`
                    }).join('')}
                    <td class="${colorClass(isRate ? item.lastYear : item['lastYear' + keySuffix])}" data-custom-perf>${isRate ? item.lastYear : item['lastYear' + keySuffix]}</td>
                </tr>`;
            });
            
            return `<div class="table-container"><table id="perf-table-${market.replace(/\s/g, '-')}">${tableHTML}</tbody></table></div>`;
        }

        // --- Cross Market Tab ---
        function renderCrossMarketTab() {
            const container = document.getElementById('market-Cross-Market');
            if (!container) return;
            container.innerHTML = `
                <div class="cross-market-controls">
                     <button data-period="ytd" class="active" onclick="updateCrossMarketChart({period: 'ytd'}, this)">YTD</button>
                     <button data-period="mtd" onclick="updateCrossMarketChart({period: 'mtd'}, this)">MTD</button>
                     <button data-period="1m" onclick="updateCrossMarketChart({period: '1m'}, this)">1-Month</button>
                     <button data-period="3m" onclick="updateCrossMarketChart({period: '3m'}, this)">3-Month</button>
                     <button data-period="custom" onclick="openCustomDateModal('cross-market')">Custom</button>
                </div>
                <div class="modal-chart-container" style="height: 600px;">
                    <canvas id="crossMarketChart"></canvas>
                </div>
            `;
            updateCrossMarketChart({ period: 'ytd' });
        }

        function updateCrossMarketChart(periodConfig, element) {
            currentCrossMarketPeriod = periodConfig;
            if(element){
                document.querySelectorAll('.cross-market-controls button').forEach(b => b.classList.remove('active'));
                element.classList.add('active');
            }
            
            let startDate, endDate = latestDataDate;
            if (periodConfig.period) {
                startDate = getStartDate(periodConfig.period, latestDataDate);
            } else {
                startDate = new Date(periodConfig.start);
                endDate = new Date(periodConfig.end);
            }

            const chartData = crossMarketAssets.tickers.map(ticker => {
                const perfData = allPerformanceData.get(ticker);
                if (!perfData) return 0;
                
                const isRate = perfData.market === 'US Rates';
                const inverted = ['JPY=', 'TWD=', 'KRW=', 'CNY='].some(inv => ticker.includes(inv));
                
                const startPrice = perfData.findPriceOnOrBefore(startDate);
                const endPrice = perfData.findPriceOnOrBefore(endDate);

                return perfData.calcPerf(startPrice, endPrice, isRate, inverted) || 0;
            });
            createCrossMarketChart(crossMarketAssets.labels, chartData, crossMarketAssets.types);
        }

        function createCrossMarketChart(labels, data, types) {
            const canvasId = 'crossMarketChart';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            if (activeCharts[canvasId]) activeCharts[canvasId].destroy();

            const isDarkMode = document.body.classList.contains('dark-mode');
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDarkMode ? '#a0a0a0' : '#555';
            const mutedTextColor = isDarkMode ? '#bbb' : '#777';
            
            const categoryLabelPlugin = {
                id: 'categoryLabels',
                afterDraw: (chart) => {
                    const { ctx, chartArea: { bottom }, scales: { x } } = chart;
                    ctx.save();
                    ctx.font = 'bold 13px sans-serif';
                    ctx.fillStyle = mutedTextColor;
                    ctx.textAlign = 'center';

                    const assetGroups = [
                        { label: 'Equity Index', start: 0, end: 1 },
                        { label: 'Stocks', start: 2, end: 3 },
                        { label: 'US Rates', start: 4, end: 5 },
                        { label: 'FX', start: 6, end: 7 },
                        { label: 'Commodity', start: 8, end: 8 }
                    ];

                    assetGroups.forEach(group => {
                        const startPixel = x.getPixelForValue(group.start);
                        const endPixel = x.getPixelForValue(group.end);
                        const middlePixel = startPixel + (endPixel - startPixel) / 2;
                        ctx.fillText(group.label, middlePixel, bottom + 45);
                    });
                    ctx.restore();
                }
            };
            
            activeCharts[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Performance',
                        data: data,
                        backgroundColor: data.map(v => v >= 0 ? 'rgba(40, 167, 69, 0.7)' : 'rgba(220, 53, 69, 0.7)'),
                        borderColor: data.map(v => v >= 0 ? 'rgba(40, 167, 69, 1)' : 'rgba(220, 53, 69, 1)'),
                        borderWidth: 1
                    }]
                },
                plugins: [categoryLabelPlugin],
                options: {
                    responsive: true, maintainAspectRatio: false, indexAxis: 'x',
                    layout: { padding: { bottom: 55 } },
                    scales: {
                        x: { 
                            grid: { display: false }, 
                            ticks: { color: textColor, font: { weight: '500' } }
                        },
                        y: { 
                            grid: { color: gridColor }, 
                            ticks: { color: textColor },
                            title: { display: true, text: 'Performance (% or bps)'}
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            if (index !== undefined && crossMarketAssets.labels[index]) {
                                showTickerChangeConfirmation(index);
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.raw.toFixed(2);
                                    const type = types[context.dataIndex];
                                    return `${label}: ${value} ${type === 'bps' ? 'bps' : '%'}`;
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                line1: { type: 'line', xMin: 1.5, xMax: 1.5, borderColor: 'rgba(128, 128, 128, 0.4)', borderWidth: 1.5, borderDash: [6, 6] },
                                line2: { type: 'line', xMin: 3.5, xMax: 3.5, borderColor: 'rgba(128, 128, 128, 0.4)', borderWidth: 1.5, borderDash: [6, 6] },
                                line3: { type: 'line', xMin: 5.5, xMax: 5.5, borderColor: 'rgba(128, 128, 128, 0.4)', borderWidth: 1.5, borderDash: [6, 6] },
                                line4: { type: 'line', xMin: 7.5, xMax: 7.5, borderColor: 'rgba(128, 128, 128, 0.4)', borderWidth: 1.5, borderDash: [6, 6] }
                            }
                        }
                    }
                }
            });
        }

        function showTickerChangeConfirmation(index) {
            const group = crossMarketAssets.groups[index];
            const label = crossMarketAssets.labels[index];
            
            const messageEl = document.getElementById('confirmationMessage');
            messageEl.innerHTML = `Would you like to select a different ticker for the <b style="color:var(--primary-color)">'${group}'</b> category?<br>(Currently: ${label})`;

            const confirmBtnYes = document.getElementById('confirmBtnYes');
            
            const newConfirmBtnYes = confirmBtnYes.cloneNode(true);
            confirmBtnYes.parentNode.replaceChild(newConfirmBtnYes, confirmBtnYes);
            
            newConfirmBtnYes.onclick = () => {
                closeModal('confirmationModal');
                showTickerSelectionModal(index);
            };
            
            openModal('confirmationModal');
        }

        function showTickerSelectionModal(index) {
            const group = crossMarketAssets.groups[index];
            if (!group) return;

            document.getElementById('tickerSelectionTitle').textContent = `Select a Ticker for ${group}`;
            const list = document.getElementById('ticker-selection-list');
            list.innerHTML = '';
            
            let tickersToShow = [];
            if (group === 'Stocks') {
                tickersToShow = [...allPerformanceData.values()].filter(d => d.market === 'US Stocks' || d.market === 'TW Stocks');
            } else {
                tickersToShow = [...allPerformanceData.values()].filter(d => d.market === group);
            }

            tickersToShow.sort((a, b) => a.name.localeCompare(b.name));

            tickersToShow.forEach(perfData => {
                if (!perfData) return;
                
                const li = document.createElement('li');
                li.textContent = `${perfData.name} (${perfData.ticker})`;
                li.onclick = () => selectNewTicker(index, perfData.ticker);
                list.appendChild(li);
            });
            openModal('tickerSelectionModal');
        }

        function selectNewTicker(index, newTicker) {
            const perfData = allPerformanceData.get(newTicker);
            if (!perfData) return;

            crossMarketAssets.tickers[index] = newTicker;
            
            let displayName = perfData.name;
            if (newTicker === 'TSM.N') displayName = 'TSM (ADR)';
            if (newTicker === '2330.TW') displayName = 'TSMC (TW)';
            crossMarketAssets.labels[index] = displayName;
            
            crossMarketAssets.types[index] = (perfData.market === 'US Rates') ? 'bps' : 'perf';
            
            closeModal('tickerSelectionModal');
            updateCrossMarketChart(currentCrossMarketPeriod);
        }


        // --- News Tab ---
        function processNewsData() {
            renderNewsSummary();
            setupNewsTabs();
        }

        function renderNewsSummary() {
            const container = document.getElementById('summary-news-card');
            const latestNews = allNewsData.length > 0 ? allNewsData[0] : null;
            
            if (latestNews) {
                container.innerHTML = `
                    <h3>${latestNews.Title}</h3>
                    <div class="news-meta"><span>${latestNews.Date || ''} ${latestNews.Time || ''}</span> | <span>Source: ${latestNews.Source || 'N/A'}</span></div>
                    <div id="summary-news-content">${latestNews.Content || 'No content available.'}</div>`;
            } else {
                container.innerHTML = `<h3>Latest News Summary</h3><div id="summary-news-content"><p>No news available.</p></div>`;
            }
            adjustSummaryNewsHeight();
        }
        
        function setupNewsTabs() {
            const tabsContainer = document.getElementById('news-sub-tabs-container');
            const contentContainer = document.getElementById('news-sub-content-container');
            tabsContainer.innerHTML = ''; contentContainer.innerHTML = '';

            const categories = {
                'Morning Briefing': '路透早報', 
                'Global Forex': '全球匯市', 
                'Taiwan Forex': '台灣匯市', 
                'US Bonds': '美國債市', 
                'Taiwan Bonds': '台灣債市'
            };
            const categoryKeys = Object.keys(categories);
            newsByCategory = { ...Object.fromEntries(categoryKeys.map(k => [k, []])), 'Other': [] };

            allNewsData.forEach(news => {
                if (!news || typeof news.Title !== 'string') return;
                let foundCategoryKey = categoryKeys.find(key => news.Title.includes(categories[key]));
                newsByCategory[foundCategoryKey || 'Other'].push(news);
            });

            [...categoryKeys, 'Other'].filter(cat => newsByCategory[cat].length > 0).forEach((category, index) => {
                const isActive = index === 0;
                tabsContainer.innerHTML += `<div class="market-sub-tab-link ${isActive ? 'active' : ''}" onclick="openNewsSubTab('${category}')">${category}</div>`;
                contentContainer.innerHTML += `<div id="news-content-${category.replace(/\s/g, '-')}" class="market-sub-tab-content ${isActive ? 'active' : ''}"></div>`;
                if(isActive) renderNewsCategory(category);
            });
        }
        function openNewsSubTab(categoryName) {
            document.querySelectorAll('#news-sub-tabs-container .market-sub-tab-link').forEach(link => link.classList.toggle('active', link.textContent === categoryName));
            document.querySelectorAll('#news-sub-content-container .market-sub-tab-content').forEach(content => {
                const id = `news-content-${categoryName.replace(/\s/g, '-')}`;
                const isActive = content.id === id;
                content.classList.toggle('active', isActive);
                if (isActive && !content.hasChildNodes()) renderNewsCategory(categoryName);
            });
        }
        function renderNewsCategory(category) {
            const categoryId = category.replace(/\s/g, '-');
            const container = document.getElementById(`news-content-${categoryId}`);
            const newsItems = newsByCategory[category];

            container.innerHTML = `<div class="news-layout-container">
                <div class="news-list-pane" id="news-list-${categoryId}"></div>
                <div class="news-content-pane" id="news-detail-${categoryId}"></div></div>`;
            
            const listPane = document.getElementById(`news-list-${categoryId}`);
            newsItems.forEach((news, index) => {
                const newsId = news.URL || `${category}-${index}`;
                const sanitizedId = newsId.replace(/[:.\/]/g, '-');
                listPane.innerHTML += `<div class="news-list-item" id="list-item-${sanitizedId}" onclick="showNewsContent('${newsId.replace(/'/g, "\\'")}', '${category}')">
                    <h4>${news.Title}</h4><p>${news.Date} ${news.Time}</p></div>`;
            });

            if (newsItems.length > 0) showNewsContent(newsItems[0].URL || `${category}-0`, category);
        }
        function showNewsContent(newsId, category) {
            const news = allNewsData.find(n => n.URL === newsId) || newsByCategory[category].find(n => (n.URL || `${category}-0`) === newsId);
            if (!news) return;

            const categoryId = category.replace(/\s/g, '-');
            document.getElementById(`news-detail-${categoryId}`).innerHTML = `
                <h3>${news.Title}</h3>
                <div class="news-meta"><span>${news.Date} ${news.Time}</span> | <span>Source: ${news.Source}</span></div>
                <div class="news-body">${news.Content}</div>`;
            
            document.querySelectorAll(`#news-list-${categoryId} .news-list-item`).forEach(item => item.classList.remove('active'));
            const sanitizedId = newsId.replace(/[:.\/]/g, '-');
            const activeItem = document.getElementById(`list-item-${sanitizedId}`);
            if (activeItem) activeItem.classList.add('active');
        }


        // --- Charting Functions (Comparison & Individual) ---
        function renderComparisonChartUI(market, performanceData) {
            const marketId = market.replace(/\s/g, '-');
            const chartContainer = document.getElementById(`chart-${marketId}`);
            const defaultTickers = performanceData.slice(0, 10).map(p => p.ticker).join(',');

            chartContainer.innerHTML = `
                <div class="chart-controls">
                    <label for="ticker-input-${marketId}">Tickers:</label>
                    <input type="text" id="ticker-input-${marketId}" value="${defaultTickers}">
                    <div class="custom-date-inputs" id="custom-date-${marketId}">
                        <input type="date" id="chart-start-${marketId}">
                        <input type="date" id="chart-end-${marketId}">
                    </div>
                    <button class="update-btn" onclick="updateComparisonChartFromUI('${market}')">Update Chart</button>
                </div>
                <div class="chart-time-controls" id="time-controls-${marketId}">
                    <button class="active" data-period="last_calendar" onclick="setComparisonChartPeriod('${market}', 'last_calendar', this)">Since Last Year</button>
                    <button data-period="ytd" onclick="setComparisonChartPeriod('${market}', 'ytd', this)">YTD</button>
                    <button data-period="3m" onclick="setComparisonChartPeriod('${market}', '3m', this)">3-Month</button>
                    <button data-period="1m" onclick="setComparisonChartPeriod('${market}', '1m', this)">1-Month</button>
                    <button data-period="custom" onclick="setComparisonChartPeriod('${market}', 'custom', this)">Custom</button>
                </div>
                <div class="modal-chart-container" style="height: 600px;"><canvas id="canvas-chart-${marketId}"></canvas></div>`;
            updateComparisonChartFromUI(market);
        }

        function setComparisonChartPeriod(market, period, element) {
            const marketId = market.replace(/\s/g, '-');
            document.querySelectorAll(`#time-controls-${marketId} button`).forEach(b => b.classList.remove('active'));
            element.classList.add('active');
             document.getElementById(`custom-date-${marketId}`).classList.toggle('active', period === 'custom');
            if (period !== 'custom') {
                updateComparisonChartFromUI(market);
            }
        }
        
        function updateComparisonChartFromUI(market) {
            const marketId = market.replace(/\s/g, '-');
            const tickers = document.getElementById(`ticker-input-${marketId}`).value.split(',').map(t => t.trim()).filter(Boolean);
            const activePeriodBtn = document.querySelector(`#time-controls-${marketId} button.active`);
            const period = activePeriodBtn.dataset.period;

            let timeConfig = { period };
            if (period === 'custom') {
                const start = document.getElementById(`chart-start-${marketId}`).value;
                const end = document.getElementById(`chart-end-${marketId}`).value;
                if (!start || !end) { return; }
                timeConfig = { start, end };
            }
            createComparisonChart(market, tickers, timeConfig);
        }

        function createComparisonChart(market, tickers, timeConfig) {
            const marketId = market.replace(/\s/g, '-');
            const canvasId = `canvas-chart-${marketId}`;
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            let startDate, endDate = latestDataDate;
            if (timeConfig.period) {
                 switch(timeConfig.period) {
                    case 'ytd': startDate = new Date(latestDataDate.getFullYear(), 0, 1); break;
                    case '3m': startDate = new Date(new Date(latestDataDate).setMonth(latestDataDate.getMonth() - 3)); break;
                    case '1m': startDate = new Date(new Date(latestDataDate).setMonth(latestDataDate.getMonth() - 1)); break;
                    default: startDate = new Date(latestDataDate.getFullYear() - 1, 0, 1); break; // last_calendar
                }
            } else {
                startDate = new Date(timeConfig.start);
                endDate = new Date(timeConfig.end);
            }
            
            const filteredData = allData.filter(d => d.date >= startDate && d.date <= endDate);
            const isRate = market === 'US Rates';
            const datasets = tickers.map((ticker, index) => {
                const tickerData = filteredData.filter(d => d.ticker === ticker);
                if (tickerData.length === 0) return null;
                const color = CHART_COLORS[index % CHART_COLORS.length];
                
                if (isRate) {
                    return { label: tickerData[0].name, data: tickerData.map(d => ({x: d.date.getTime(), y: d.price})), borderColor: color, backgroundColor: color + '33', borderWidth: 2, pointRadius: 0 };
                }
                const firstPrice = tickerData[0].price;
                if(firstPrice === 0) return null;
                const normalizedData = tickerData.map(d => ({ x: d.date.getTime(), y: ((d.price / firstPrice) - 1) * 100 }));
                return { label: tickerData[0].name, data: normalizedData, borderColor: color, backgroundColor: color + '33', borderWidth: 2, pointRadius: 0 };
            }).filter(Boolean);

            if (activeCharts[canvasId]) activeCharts[canvasId].destroy();
            const isDarkMode = document.body.classList.contains('dark-mode');
            activeCharts[canvasId] = new Chart(ctx, {
                type: 'line', data: { datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: { 
                        x: { type: 'time', time: { unit: 'month' }, ticks: { color: isDarkMode ? '#a0a0a0' : '#555' } }, 
                        y: { title: { display: true, text: isRate ? 'Rate' : 'Performance (%)' }, ticks: { color: isDarkMode ? '#a0a0a0' : '#555' } } 
                    },
                    plugins: { legend: { labels: { color: isDarkMode ? '#f0f0f0' : '#333' } } }
                }
            });
        }
        
        const yearAxisPlugin = {
            id: 'yearAxis',
            afterDraw: (chart) => {
                const years = chart.options.plugins.yearAxis.years;
                if (!years || Object.keys(years).length === 0) return;
                const { ctx, chartArea: { bottom, left, right }, scales: { x } } = chart;
                
                ctx.save();
                ctx.font = '14px sans-serif';
                ctx.fillStyle = document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.7)';
                ctx.textAlign = 'center';

                for (const year in years) {
                    const yearData = years[year];
                    const midPoint = (yearData.min + yearData.max) / 2;
                    const xPos = x.getPixelForValue(midPoint);
                    
                    if (xPos >= left && xPos <= right) {
                         ctx.fillText(year, xPos, bottom + 55);
                    }
                }
                ctx.restore();
            }
        };

        const tooltipYearAxisPlugin = {
            id: 'tooltipYearAxis',
            afterDraw: (chart) => {
                const years = chart.options.plugins.yearAxis.years;
                if (!years || Object.keys(years).length === 0) return;
                const { ctx, chartArea: { bottom, left, right }, scales: { x } } = chart;
                
                ctx.save();
                ctx.font = '10px sans-serif';
                ctx.fillStyle = document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.7)';
                ctx.textAlign = 'center';

                for (const year in years) {
                    const yearData = years[year];
                    const midPoint = (yearData.min + yearData.max) / 2;
                    const xPos = x.getPixelForValue(midPoint);
                    
                    if (xPos >= left && xPos <= right) {
                         ctx.fillText(year, xPos, bottom + 15);
                    }
                }
                ctx.restore();
            }
        };

        function showIndividualTickerChart(ticker, period = 'last_calendar') {
            const modal = document.getElementById('tickerModal');
            const tickerData = allData.filter(d => d.ticker === ticker);
            if (tickerData.length === 0) return;

            const name = tickerData[0].name;
            document.getElementById('modalTickerName').textContent = `${name} (${ticker})`;
            
            const timeControls = document.getElementById('modal-time-controls');
            timeControls.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.period === period);
                btn.onclick = () => showIndividualTickerChart(ticker, btn.dataset.period);
            });

            const tempDate = new Date(latestDataDate);
            let startDate;
            switch(period) {
                case '3m': startDate = new Date(new Date(tempDate).setMonth(tempDate.getMonth() - 3)); break;
                case '6m': startDate = new Date(new Date(tempDate).setMonth(tempDate.getMonth() - 6)); break;
                case 'ytd': startDate = new Date(tempDate.getFullYear(), 0, 1); break;
                case '5y': startDate = new Date(new Date(tempDate).setFullYear(tempDate.getFullYear() - 5)); break;
                default: startDate = new Date(latestDataDate.getFullYear() - 1, 0, 1); break;
            }

            const chartData = tickerData.filter(d => d.date >= startDate).map(d => ({ x: d.date.getTime(), y: d.price }));
            
            const canvasId = 'individualTickerChart';
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (activeCharts[canvasId]) activeCharts[canvasId].destroy();

            if (chartData.length < 2) {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.font = "16px sans-serif";
                ctx.fillStyle = "#888";
                ctx.textAlign = "center";
                ctx.fillText("Not enough data to display chart for this period.", ctx.canvas.width / 2, ctx.canvas.height / 2);
            } else {
                let minPoint = chartData[0], maxPoint = chartData[0];
                chartData.forEach(p => {
                    if (p.y < minPoint.y) minPoint = p;
                    if (p.y > maxPoint.y) maxPoint = p;
                });

                const getLabelAnnotation = (point, content, defaultYAdjust) => {
                    const label = {
                        type: 'label', xValue: point.x, yValue: point.y, content: content,
                        font: { size: 12 }, yAdjust: defaultYAdjust,
                        backgroundColor: document.body.classList.contains('dark-mode') ? 'rgba(50,50,50,0.85)' : 'rgba(255, 255, 255, 0.85)',
                        color: document.body.classList.contains('dark-mode') ? '#f0f0f0' : '#333',
                        padding: 4, borderRadius: 4,
                    };
                    const pointIndex = chartData.findIndex(p => p.x === point.x);
                    if (pointIndex < chartData.length / 2) {
                        label.xAdjust = 5; label.textAlign = 'left';
                    } else {
                        label.xAdjust = -5; label.textAlign = 'right';
                    }
                    return label;
                };
                
                const yearAnnotations = {};
                const yearsInData = {};
                chartData.forEach(d => {
                    const year = new Date(d.x).getFullYear();
                    if (!yearsInData[year]) yearsInData[year] = { min: d.x, max: d.x };
                    else {
                        yearsInData[year].min = Math.min(yearsInData[year].min, d.x);
                        yearsInData[year].max = Math.max(yearsInData[year].max, d.x);
                    }
                });

                Object.keys(yearsInData).sort().forEach((year, index) => {
                    if (index > 0) {
                        const yearStartDate = new Date(parseInt(year), 0, 1).getTime();
                        yearAnnotations[`yearLine${year}`] = {
                            type: 'line', xMin: yearStartDate, xMax: yearStartDate,
                            borderColor: 'rgba(128, 128, 128, 0.5)', borderWidth: 1, borderDash: [6, 6]
                        };
                    }
                });
                
                const isDarkMode = document.body.classList.contains('dark-mode');
                const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                const textColor = isDarkMode ? '#a0a0a0' : '#555';

                activeCharts[canvasId] = new Chart(ctx, {
                    type: 'line',
                    data: { datasets: [{ 
                        label: 'Price', data: chartData, borderColor: 'rgba(74, 144, 226, 1)', 
                        backgroundColor: 'rgba(74, 144, 226, 0.2)', borderWidth: 2, 
                        fill: true, pointRadius: 0, tension: 0.1 
                    }] },
                    plugins: [yearAxisPlugin],
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        layout: { padding: { bottom: 40 } },
                        scales: {
                            x: {
                                type: 'time', time: { unit: 'month', displayFormats: { month: 'MMM' } },
                                ticks: { source: 'auto', maxRotation: 0, autoSkip: true, color: textColor },
                                grid: { color: gridColor }
                            },
                            y: { 
                                position: 'right', title: { display: true, text: 'Price' },
                                ticks: { color: textColor },
                                grid: { color: gridColor }
                            }
                        },
                        plugins: {
                            yearAxis: { years: yearsInData },
                            legend: { display: false },
                            tooltip: { mode: 'index', intersect: false, callbacks: {
                                title: (tooltipItems) => formatDateMMDD(new Date(tooltipItems[0].parsed.x))
                            }},
                            annotation: {
                                annotations: {
                                    ...yearAnnotations,
                                    highPoint: { type: 'point', xValue: maxPoint.x, yValue: maxPoint.y, backgroundColor: 'rgba(220, 53, 69, 0.8)', radius: 5 },
                                    highLabel: getLabelAnnotation(maxPoint, `High: ${formatNumberWithCommas(maxPoint.y.toFixed(2))}`, -15),
                                    lowPoint: { type: 'point', xValue: minPoint.x, yValue: minPoint.y, backgroundColor: 'rgba(40, 167, 69, 0.8)', radius: 5 },
                                    lowLabel: getLabelAnnotation(minPoint, `Low: ${formatNumberWithCommas(minPoint.y.toFixed(2))}`, 15)
                                }
                            }
                        }
                    }
                });
            }
            openModal('tickerModal');
        }

        // --- Event Listeners & Interactions ---
        function sortTable(market, sortKey, thElement) {
            const marketId = market.replace(/\s/g, '-');
            const table = document.getElementById(`perf-table-${marketId}`);
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            if (!marketSortState[market]) {
                marketSortState[market] = { key: null, dir: 'asc' };
            }

            let direction = 'asc';
            if (marketSortState[market].key === sortKey && marketSortState[market].dir === 'asc') {
                direction = 'desc';
            }
            marketSortState[market] = { key: sortKey, dir: direction };
            
            table.querySelectorAll('th .sort-icon').forEach(icon => icon.textContent = '↕');
            thElement.querySelector('.sort-icon').textContent = direction === 'asc' ? '▲' : '▼';
            
            const isRate = market === 'US Rates';

            rows.sort((a, b) => {
                const aPerf = allPerformanceData.get(a.dataset.ticker);
                const bPerf = allPerformanceData.get(b.dataset.ticker);
                let valA, valB;

                if (sortKey === 'name' || sortKey === 'lastDate') {
                    valA = aPerf[sortKey];
                    valB = bPerf[sortKey];
                } else {
                    const keySuffix = (performanceDisplayMode === 'percent' && !isRate) ? '_raw' : '_pts_raw';
                    let key = sortKey === 'lastPrice' ? 'lastPrice' : sortKey + (isRate ? '_raw' : keySuffix);
                    valA = aPerf[key];
                    valB = bPerf[key];
                }
                
                if (valA === null || valA === undefined || isNaN(valA)) valA = direction === 'asc' ? Infinity : -Infinity;
                if (valB === null || valB === undefined || isNaN(valB)) valB = direction === 'asc' ? Infinity : -Infinity;

                if (typeof valA === 'string') {
                    return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                } else {
                    if (valA < valB) return direction === 'asc' ? -1 : 1;
                    if (valA > valB) return direction === 'asc' ? 1 : -1;
                    return 0;
                }
            });

            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));
        }

        function addTableEventListeners(market) {
            const marketId = market.replace(/\s/g, '-');
            const table = document.getElementById(`perf-table-${marketId}`);
            if (!table) return;

            table.querySelector('thead').addEventListener('click', (event) => {
                const th = event.target.closest('th[data-sort-key]');
                if (th) {
                    sortTable(market, th.dataset.sortKey, th);
                }
            });
            table.querySelector('tbody').addEventListener('click', (event) => {
                const row = event.target.closest('tr');
                if (row && row.dataset.ticker) {
                    showIndividualTickerChart(row.dataset.ticker);
                }
            });
        }
        
        function addSummaryTooltipEvents() {
            const tooltip = document.getElementById('chart-tooltip');
            document.querySelectorAll('.summary-card tbody tr[data-ticker]').forEach(row => {
                const ticker = row.dataset.ticker;
                if (!ticker) return;
                row.addEventListener('mouseenter', (e) => showTooltipChart(e, ticker));
                row.addEventListener('mousemove', (e) => { 
                    const tooltipWidth = tooltip.offsetWidth;
                    const tooltipHeight = tooltip.offsetHeight;
                    let left = e.clientX + 15;
                    let top = e.clientY + 15;
                    if (left + tooltipWidth > window.innerWidth) left = e.clientX - tooltipWidth - 15;
                    if (top + tooltipHeight > window.innerHeight) top = e.clientY - tooltipHeight - 15;
                    tooltip.style.left = `${left}px`; 
                    tooltip.style.top = `${top}px`; 
                });
                row.addEventListener('mouseleave', hideTooltipChart);
            });
        }

        function showTooltipChart(event, ticker) {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
            }
            tooltipTimeout = setTimeout(() => {
                const tooltip = document.getElementById('chart-tooltip');
                if (!tooltip) return;

                const endDate = new Date(latestDataDate);
                const startDate = getStartDate('ytd', endDate);

                if (!startDate || isNaN(startDate.getTime())) {
                    hideTooltipChart();
                    return;
                }
               
                const chartData = allData
                    .filter(d => d.ticker === ticker && d.date >= startDate && d.date <= endDate)
                    .map(d => ({x: d.date.getTime(), y: d.price}));
                
                if (tooltipChart) {
                    tooltipChart.destroy();
                    tooltipChart = null;
                }

                if (chartData.length < 2) {
                    hideTooltipChart();
                    return;
                }
                
                tooltip.classList.add('visible');
                
                requestAnimationFrame(() => {
                    const canvas = document.getElementById('tooltip-canvas');
                    if (!canvas || !tooltip.classList.contains('visible')) return; 
                    const ctx = canvas.getContext('2d');
                    if (!ctx) return;
                    
                    let minPoint = chartData[0], maxPoint = chartData[0];
                    chartData.forEach(p => {
                        if (p.y < minPoint.y) minPoint = p;
                        if (p.y > maxPoint.y) maxPoint = p;
                    });

                    const getLabelAnnotation = (point, content, defaultYAdjust) => {
                        const label = {
                            type: 'label', xValue: point.x, yValue: point.y, content: content,
                            font: { size: 10 }, yAdjust: defaultYAdjust,
                            backgroundColor: document.body.classList.contains('dark-mode') ? 'rgba(50,50,50,0.85)' : 'rgba(255, 255, 255, 0.85)',
                            color: document.body.classList.contains('dark-mode') ? '#f0f0f0' : '#333',
                            padding: 2, borderRadius: 2
                        };
                        const pointIndex = chartData.findIndex(p => p.x === point.x);
                        if (pointIndex < chartData.length / 2) { label.xAdjust = 5; label.textAlign = 'left'; } 
                        else { label.xAdjust = -5; label.textAlign = 'right'; }
                        return label;
                    };

                    const yearAnnotations = {};
                    const yearsInData = {};
                    chartData.forEach(d => {
                        const year = new Date(d.x).getFullYear();
                        if (!yearsInData[year]) yearsInData[year] = { min: d.x, max: d.x };
                        else {
                            yearsInData[year].min = Math.min(yearsInData[year].min, d.x);
                            yearsInData[year].max = Math.max(yearsInData[year].max, d.x);
                        }
                    });
                    
                    Object.keys(yearsInData).sort().forEach((year, index) => {
                        if (index > 0) {
                            const yearStartDate = new Date(parseInt(year), 0, 1).getTime();
                            yearAnnotations[`yearLine${year}`] = {
                                type: 'line', xMin: yearStartDate, xMax: yearStartDate,
                                borderColor: 'rgba(128, 128, 128, 0.5)', borderWidth: 1, borderDash: [2, 2]
                            };
                        }
                    });

                    tooltipChart = new Chart(ctx, {
                        type: 'line',
                        data: { datasets: [{ 
                            data: chartData, borderColor: 'rgba(74, 144, 226, 1)', 
                            backgroundColor: 'rgba(74, 144, 226, 0.2)', borderWidth: 1.5, 
                            fill: true, pointRadius: 0, tension: 0.1 
                        }] },
                        plugins: [tooltipYearAxisPlugin],
                        options: {
                            responsive: true, maintainAspectRatio: false,
                            layout: { padding: { top: 15, bottom: 25, left: 5, right: 5 } },
                            scales: { x: { display: false }, y: { display: false } },
                            plugins: {
                                yearAxis: { years: yearsInData },
                                legend: { display: false },
                                tooltip: { enabled: false },
                                annotation: {
                                    annotations: {
                                        ...yearAnnotations,
                                        highPoint: { type: 'point', xValue: maxPoint.x, yValue: maxPoint.y, backgroundColor: 'rgba(220, 53, 69, 0.8)', radius: 3 },
                                        highLabel: getLabelAnnotation(maxPoint, `H: ${formatNumberWithCommas(maxPoint.y.toFixed(2))}`, -10),
                                        lowPoint: { type: 'point', xValue: minPoint.x, yValue: minPoint.y, backgroundColor: 'rgba(40, 167, 69, 0.8)', radius: 3 },
                                        lowLabel: getLabelAnnotation(minPoint, `L: ${formatNumberWithCommas(minPoint.y.toFixed(2))}`, 10)
                                    }
                                }
                            },
                            animation: { duration: 0 }
                        }
                    });
                });
            }, 50); 
        }
        
        function hideTooltipChart() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
            
            const tooltip = document.getElementById('chart-tooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
            }
            
            if (tooltipChart) { 
                tooltipChart.destroy(); 
                tooltipChart = null; 
            }
        }

        function openCustomDateModal(context) {
            activeCustomDateContext = context;
            const applyBtn = document.getElementById('applyCustomDate');
            if (context === 'summary') {
                applyBtn.onclick = applyCustomDateToSummary;
            } else if (context === 'cross-market') {
                applyBtn.onclick = applyCustomDateToCrossMarket;
            } else {
                applyBtn.onclick = () => applyCustomDateToTable(context);
            }
            openModal('datePickerModal');
        }
        
        function applyCustomDateToSummary() {
            const start = document.getElementById('customStartDate').value;
            const end = document.getElementById('customEndDate').value;
            if (!start || !end || new Date(start) > new Date(end)) { return; }
            
            const customPeriod = { start, end };
            const customButton = document.querySelector('.summary-period-controls button[data-period="custom"]');
            updateSummaryView(customPeriod, customButton);
            closeModal('datePickerModal');
        }

        function applyCustomDateToCrossMarket() {
            const start = document.getElementById('customStartDate').value;
            const end = document.getElementById('customEndDate').value;
            if (!start || !end || new Date(start) > new Date(end)) { return; }
            
            const customPeriod = { start, end };
            const customButton = document.querySelector('.cross-market-controls button[data-period="custom"]');
            updateCrossMarketChart(customPeriod, customButton);
            closeModal('datePickerModal');
        }

        function applyCustomDateToTable(market) {
            const startDate = new Date(document.getElementById('customStartDate').value);
            const endDate = new Date(document.getElementById('customEndDate').value);
            if (isNaN(startDate) || isNaN(endDate) || startDate > endDate) { return; }

            const marketId = market.replace(/\s/g, '-');
            const table = document.getElementById(`perf-table-${marketId}`);
            const isRate = market === 'US Rates';
            const isPercent = performanceDisplayMode === 'percent';
            
            table.querySelectorAll('tbody tr').forEach(row => {
                const ticker = row.dataset.ticker;
                const perfData = allPerformanceData.get(ticker);
                if (!perfData) return;
                
                const inverted = ['JPY=', 'TWD=', 'KRW=', 'CNY='].some(inv => ticker.includes(inv));
                const tickerData = allData.filter(d => d.ticker === ticker);

                const startPrice = perfData.findPriceOnOrBefore(startDate, tickerData);
                const endPrice = perfData.findPriceOnOrBefore(endDate, tickerData);
                
                let perfValue, rawValue;
                if (isRate) {
                    rawValue = perfData.calcPerf(startPrice, endPrice, true, inverted);
                    perfValue = (rawValue === null || isNaN(rawValue)) ? 'N/A' : `${rawValue.toFixed(0)} bps`;
                } else {
                    if (isPercent) {
                         rawValue = perfData.calcPerf(startPrice, endPrice, false, inverted);
                         perfValue = (rawValue === null || isNaN(rawValue)) ? 'N/A' : `${rawValue.toFixed(2)}%`;
                    } else {
                         rawValue = (startPrice !== null && endPrice !== null) ? endPrice - startPrice : null;
                         perfValue = (rawValue === null || isNaN(rawValue)) ? 'N/A' : formatNumberWithCommas(rawValue.toFixed(perfData.market === 'FX' ? 4 : 2));
                    }
                }

                const perfCell = row.querySelector('[data-custom-perf]');
                perfCell.textContent = perfValue;
                perfCell.className = ''; 
                if (rawValue > 0) perfCell.classList.add('text-positive');
                if (rawValue < 0) perfCell.classList.add('text-negative');

            });

            const header = table.querySelector('.custom-date-header');
            const suffix = isRate ? ' (bps)' : isPercent ? ' (%)' : ' (Pts)';
            header.innerHTML = `${formatDateMMDD(startDate)}-<br>${formatDateMMDD(endDate)} Perf.${suffix}`;
            closeModal('datePickerModal');
        }


        // --- UI Utility Functions ---
        function togglePerformanceDisplayMode() {
            performanceDisplayMode = performanceDisplayMode === 'percent' ? 'points' : 'percent';
            
            const isPercent = performanceDisplayMode === 'percent';
            document.querySelectorAll('.display-mode-toggle').forEach(btn => {
                btn.textContent = isPercent ? 'Show Points' : 'Show %';
            });

            const activeTab = document.querySelector('.tab-link.active');
            if (!activeTab) return;

            if (activeTab.textContent === 'Summary') {
                renderSummaryTab();
            } else if (activeTab.textContent === 'Market') {
                const activeMarketTab = document.querySelector('#market-sub-tabs-container .market-sub-tab-link.active');
                if (activeMarketTab) {
                    renderMarketData(activeMarketTab.textContent);
                }
            }
        }
        function formatDateMMDD(date) { return date instanceof Date && !isNaN(date) ? `${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}` : ''; }
        function adjustSummaryNewsHeight() {
             setTimeout(() => {
                const fxCard = document.getElementById('summary-fx');
                const stocksCard = document.getElementById('summary-stocks');
                const newsCard = document.getElementById('summary-news-card');
                if (fxCard && stocksCard && newsCard && window.innerWidth > 1250) { 
                    newsCard.style.height = `${fxCard.offsetHeight + stocksCard.offsetHeight + 20}px`;
                } else if (newsCard) {
                    newsCard.style.height = 'auto';
                }
            }, 100);
        }
        function openModal(modalId) { const m = document.getElementById(modalId); m.style.display='block'; setTimeout(() => m.classList.add('show'), 10); document.body.style.overflow = 'hidden'; }
        function closeModal(modalId) {
            const m = document.getElementById(modalId);
            if(!m) return;
            m.classList.remove('show');
            setTimeout(() => { 
                m.style.display = 'none';
                if (!document.querySelector('.modal.show')) {
                    document.body.style.overflow = '';
                }
            }, 300);

            if (modalId === 'tickerModal') {
                const canvasId = 'individualTickerChart';
                if (activeCharts[canvasId]) {
                    activeCharts[canvasId].destroy();
                    delete activeCharts[canvasId];
                }
            }
        }
        function openTab(evt, tabName) {
            document.querySelectorAll(".tab-content, .tab-link").forEach(el => el.classList.remove("active"));
            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");
            
            if (tabName === 'market') {
                const activeSubTab = document.querySelector('#market-sub-tabs-container .market-sub-tab-link.active');
                if (activeSubTab && activeSubTab.textContent === 'Cross Market') {
                    updateCrossMarketChart(currentCrossMarketPeriod);
                }
            }
        }
        function initTheme() {
            const isDarkMode = localStorage.getItem('theme') === 'dark';
            document.body.classList.toggle('dark-mode', isDarkMode);
            document.getElementById('theme-icon-sun').style.display = isDarkMode ? 'none' : 'block';
            document.getElementById('theme-icon-moon').style.display = isDarkMode ? 'block' : 'none';
        }
        function toggleTheme() {
            const isDarkMode = document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            document.getElementById('theme-icon-sun').style.display = isDarkMode ? 'none' : 'block';
            document.getElementById('theme-icon-moon').style.display = isDarkMode ? 'block' : 'none';
            
            Object.values(activeCharts).forEach(chart => {
                if (chart && chart.options) {
                    const textColor = isDarkMode ? '#a0a0a0' : '#555';
                    const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                    if (chart.options.scales.x) chart.options.scales.x.ticks.color = textColor;
                    if (chart.options.scales.y) chart.options.scales.y.ticks.color = textColor;
                    if (chart.options.scales.x) chart.options.scales.x.grid.color = gridColor;
                    if (chart.options.scales.y) chart.options.scales.y.grid.color = gridColor;
                    if(chart.options.plugins.legend) {
                       chart.options.plugins.legend.labels.color = isDarkMode ? '#f0f0f0' : '#333';
                    }
                    if(chart.canvas.id === 'individualTickerChart' && chart.options.plugins.annotation) {
                        Object.values(chart.options.plugins.annotation.annotations).forEach(annotation => {
                            if(annotation.type === 'label') {
                                annotation.backgroundColor = isDarkMode ? 'rgba(50,50,50,0.85)' : 'rgba(255, 255, 255, 0.85)';
                                annotation.color = isDarkMode ? '#f0f0f0' : '#333';
                            }
                        });
                    }
                    chart.update();
                }
            });
        }
    </script>
</body>
</html>

